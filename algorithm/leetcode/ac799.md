# AC799 双指针算法
```
给定一个长度为 n 的整数序列，请找出最长的不包含重复的数的连续区间，输出它的长度。

输入格式
    第一行包含整数 n。
    第二行包含 n 个整数（均在 0∼105 范围内），表示整数序列。

输出格式
    共一行，包含一个整数，表示最长的不包含重复的数的连续区间的长度。

数据范围
    1≤n≤105

输入样例：
    5
    1 2 2 3 5

输出样例：
    3
```
1. 本题要求找出最长的不包含重复数的连续区间，首先想到采用双指针算法维护一个区间，该区间内没有重复的元素。每当右边界指针后移一位时，检查新加入的元素和原本区间内的元素是否重复，如果重复，则将左边界右移至重复值的后一位。
```cpp
#include <iostream>
using namespace std;
const int N = 100010;
int q[N];
int main()
{
    int num,max=0;
    num = 100000;
    //cin>>num;
    for(int i=0;i<num;i++)
    {
        q[i]=i;
        //cin>>q[i];
    }
    for(int i=1,j=0;i<num;i++)
    {
        for(int k=j;k<i;k++)
        {
            if(q[k]==q[i])
            {
                j=k+1;
                break;
            }
        }
        max = (max<(i-j+1))?i-j+1:max;
    }
    cout<<max;
    return 0;
}
```
2. 进一步优化该算法，每次检查新加入的元素是否重复会导致本算法的时间复杂度升为O(n^2),所以采用空间换时间的方法。重新开辟一个数组，用于记录每个数在区间内出现的次数，对于新加入的数，直接使用数组的随机访问特性，查找区间内该数对应的下标，如果大于2，则发现重复，此时将左边界右移并更新区间数组。
```cpp
#include <iostream>
using namespace std;
const int N = 100010;
int q[N],s[N];
int main()
{
    int num,max=0;
    cin>>num;
    for(int i=0;i<num;i++)
    {
        cin>>q[i];
    }
    for(int j=0,i=0;i<num;i++)
    {
        s[q[i]]++;
        if(s[q[i]]>1)
        {
            for(int k=j;k<i;k++)
            {
                s[q[k]]--;
                if(q[k]==q[i])
                {
                    j=k+1;
                    break;
                }
            }
        }
        max = (max<i-j+1)?i-j+1:max;
    }
    cout<<max;
    return 0;
}
```
**双指针算法是一种很常用的算法，在许多地方都有使用，例如快速排序等，思考双指针算法其实可以先从最朴素的方法开始思考，以本题为例，其实最简单的想法就是遍历所有区间，找到最长的不含重复元素的区间。然后进一步思考寻找i，j间的具体关系，我们会发现一旦发现了含有重复元素的部分那么从区间左边界，到第一个重复元素的所有区间左边界其实都可以不用考虑了，从而优化了部分算法。**